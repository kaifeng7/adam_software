// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/map.proto

#ifndef PROTOBUF_INCLUDED_proto_2fmap_2eproto
#define PROTOBUF_INCLUDED_proto_2fmap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_proto_2fmap_2eproto 

namespace protobuf_proto_2fmap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_proto_2fmap_2eproto
namespace adam {
namespace map {
class A;
class ADefaultTypeInternal;
extern ADefaultTypeInternal _A_default_instance_;
class Arc;
class ArcDefaultTypeInternal;
extern ArcDefaultTypeInternal _Arc_default_instance_;
class B;
class BDefaultTypeInternal;
extern BDefaultTypeInternal _B_default_instance_;
class Connection;
class ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class ConnectionLaneLink;
class ConnectionLaneLinkDefaultTypeInternal;
extern ConnectionLaneLinkDefaultTypeInternal _ConnectionLaneLink_default_instance_;
class Geometry;
class GeometryDefaultTypeInternal;
extern GeometryDefaultTypeInternal _Geometry_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Junction;
class JunctionDefaultTypeInternal;
extern JunctionDefaultTypeInternal _Junction_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneSection;
class LaneSectionDefaultTypeInternal;
extern LaneSectionDefaultTypeInternal _LaneSection_default_instance_;
class LaneSet;
class LaneSetDefaultTypeInternal;
extern LaneSetDefaultTypeInternal _LaneSet_default_instance_;
class LaneWidth;
class LaneWidthDefaultTypeInternal;
extern LaneWidthDefaultTypeInternal _LaneWidth_default_instance_;
class Lanes;
class LanesDefaultTypeInternal;
extern LanesDefaultTypeInternal _Lanes_default_instance_;
class Line;
class LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class Map;
class MapDefaultTypeInternal;
extern MapDefaultTypeInternal _Map_default_instance_;
class PlainView;
class PlainViewDefaultTypeInternal;
extern PlainViewDefaultTypeInternal _PlainView_default_instance_;
class Road;
class RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadLink;
class RoadLinkDefaultTypeInternal;
extern RoadLinkDefaultTypeInternal _RoadLink_default_instance_;
class RoadLinker;
class RoadLinkerDefaultTypeInternal;
extern RoadLinkerDefaultTypeInternal _RoadLinker_default_instance_;
class RoadMark;
class RoadMarkDefaultTypeInternal;
extern RoadMarkDefaultTypeInternal _RoadMark_default_instance_;
}  // namespace map
}  // namespace adam
namespace google {
namespace protobuf {
template<> ::adam::map::A* Arena::CreateMaybeMessage<::adam::map::A>(Arena*);
template<> ::adam::map::Arc* Arena::CreateMaybeMessage<::adam::map::Arc>(Arena*);
template<> ::adam::map::B* Arena::CreateMaybeMessage<::adam::map::B>(Arena*);
template<> ::adam::map::Connection* Arena::CreateMaybeMessage<::adam::map::Connection>(Arena*);
template<> ::adam::map::ConnectionLaneLink* Arena::CreateMaybeMessage<::adam::map::ConnectionLaneLink>(Arena*);
template<> ::adam::map::Geometry* Arena::CreateMaybeMessage<::adam::map::Geometry>(Arena*);
template<> ::adam::map::Header* Arena::CreateMaybeMessage<::adam::map::Header>(Arena*);
template<> ::adam::map::Junction* Arena::CreateMaybeMessage<::adam::map::Junction>(Arena*);
template<> ::adam::map::Lane* Arena::CreateMaybeMessage<::adam::map::Lane>(Arena*);
template<> ::adam::map::LaneSection* Arena::CreateMaybeMessage<::adam::map::LaneSection>(Arena*);
template<> ::adam::map::LaneSet* Arena::CreateMaybeMessage<::adam::map::LaneSet>(Arena*);
template<> ::adam::map::LaneWidth* Arena::CreateMaybeMessage<::adam::map::LaneWidth>(Arena*);
template<> ::adam::map::Lanes* Arena::CreateMaybeMessage<::adam::map::Lanes>(Arena*);
template<> ::adam::map::Line* Arena::CreateMaybeMessage<::adam::map::Line>(Arena*);
template<> ::adam::map::Map* Arena::CreateMaybeMessage<::adam::map::Map>(Arena*);
template<> ::adam::map::PlainView* Arena::CreateMaybeMessage<::adam::map::PlainView>(Arena*);
template<> ::adam::map::Road* Arena::CreateMaybeMessage<::adam::map::Road>(Arena*);
template<> ::adam::map::RoadLink* Arena::CreateMaybeMessage<::adam::map::RoadLink>(Arena*);
template<> ::adam::map::RoadLinker* Arena::CreateMaybeMessage<::adam::map::RoadLinker>(Arena*);
template<> ::adam::map::RoadMark* Arena::CreateMaybeMessage<::adam::map::RoadMark>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace adam {
namespace map {

// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string date = 5;
  void clear_date();
  static const int kDateFieldNumber = 5;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // float version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  float version() const;
  void set_version(float value);

  // @@protoc_insertion_point(class_scope:adam.map.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  float version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Geometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Geometry) */ {
 public:
  Geometry();
  virtual ~Geometry();

  Geometry(const Geometry& from);

  inline Geometry& operator=(const Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Geometry(Geometry&& from) noexcept
    : Geometry() {
    *this = ::std::move(from);
  }

  inline Geometry& operator=(Geometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Geometry& default_instance();

  enum ShapeCase {
    kLine = 6,
    kArc = 7,
    SHAPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geometry* internal_default_instance() {
    return reinterpret_cast<const Geometry*>(
               &_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Geometry* other);
  friend void swap(Geometry& a, Geometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geometry* New() const final {
    return CreateMaybeMessage<Geometry>(NULL);
  }

  Geometry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Geometry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Geometry& from);
  void MergeFrom(const Geometry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double s = 1;
  void clear_s();
  static const int kSFieldNumber = 1;
  double s() const;
  void set_s(double value);

  // double x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  double x() const;
  void set_x(double value);

  // double y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  double y() const;
  void set_y(double value);

  // double hdg = 4;
  void clear_hdg();
  static const int kHdgFieldNumber = 4;
  double hdg() const;
  void set_hdg(double value);

  // double length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  double length() const;
  void set_length(double value);

  // .adam.map.Line line = 6;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 6;
  private:
  const ::adam::map::Line& _internal_line() const;
  public:
  const ::adam::map::Line& line() const;
  ::adam::map::Line* release_line();
  ::adam::map::Line* mutable_line();
  void set_allocated_line(::adam::map::Line* line);

  // .adam.map.Arc arc = 7;
  bool has_arc() const;
  void clear_arc();
  static const int kArcFieldNumber = 7;
  private:
  const ::adam::map::Arc& _internal_arc() const;
  public:
  const ::adam::map::Arc& arc() const;
  ::adam::map::Arc* release_arc();
  ::adam::map::Arc* mutable_arc();
  void set_allocated_arc(::adam::map::Arc* arc);

  void clear_shape();
  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:adam.map.Geometry)
 private:
  void set_has_line();
  void set_has_arc();

  inline bool has_shape() const;
  inline void clear_has_shape();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double s_;
  double x_;
  double y_;
  double hdg_;
  double length_;
  union ShapeUnion {
    ShapeUnion() {}
    ::adam::map::Line* line_;
    ::adam::map::Arc* arc_;
  } shape_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Line : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Line) */ {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(Line&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Line& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Line* other);
  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Line* New() const final {
    return CreateMaybeMessage<Line>(NULL);
  }

  Line* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:adam.map.Line)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Arc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Arc) */ {
 public:
  Arc();
  virtual ~Arc();

  Arc(const Arc& from);

  inline Arc& operator=(const Arc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Arc(Arc&& from) noexcept
    : Arc() {
    *this = ::std::move(from);
  }

  inline Arc& operator=(Arc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Arc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Arc* internal_default_instance() {
    return reinterpret_cast<const Arc*>(
               &_Arc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Arc* other);
  friend void swap(Arc& a, Arc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Arc* New() const final {
    return CreateMaybeMessage<Arc>(NULL);
  }

  Arc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Arc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Arc& from);
  void MergeFrom(const Arc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Arc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double curvature = 1;
  void clear_curvature();
  static const int kCurvatureFieldNumber = 1;
  double curvature() const;
  void set_curvature(double value);

  // @@protoc_insertion_point(class_scope:adam.map.Arc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double curvature_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlainView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.PlainView) */ {
 public:
  PlainView();
  virtual ~PlainView();

  PlainView(const PlainView& from);

  inline PlainView& operator=(const PlainView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlainView(PlainView&& from) noexcept
    : PlainView() {
    *this = ::std::move(from);
  }

  inline PlainView& operator=(PlainView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlainView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlainView* internal_default_instance() {
    return reinterpret_cast<const PlainView*>(
               &_PlainView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PlainView* other);
  friend void swap(PlainView& a, PlainView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlainView* New() const final {
    return CreateMaybeMessage<PlainView>(NULL);
  }

  PlainView* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlainView>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlainView& from);
  void MergeFrom(const PlainView& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlainView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .adam.map.Geometry geometry = 1;
  int geometry_size() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  ::adam::map::Geometry* mutable_geometry(int index);
  ::google::protobuf::RepeatedPtrField< ::adam::map::Geometry >*
      mutable_geometry();
  const ::adam::map::Geometry& geometry(int index) const;
  ::adam::map::Geometry* add_geometry();
  const ::google::protobuf::RepeatedPtrField< ::adam::map::Geometry >&
      geometry() const;

  // @@protoc_insertion_point(class_scope:adam.map.PlainView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::adam::map::Geometry > geometry_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lanes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Lanes) */ {
 public:
  Lanes();
  virtual ~Lanes();

  Lanes(const Lanes& from);

  inline Lanes& operator=(const Lanes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lanes(Lanes&& from) noexcept
    : Lanes() {
    *this = ::std::move(from);
  }

  inline Lanes& operator=(Lanes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lanes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lanes* internal_default_instance() {
    return reinterpret_cast<const Lanes*>(
               &_Lanes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Lanes* other);
  friend void swap(Lanes& a, Lanes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lanes* New() const final {
    return CreateMaybeMessage<Lanes>(NULL);
  }

  Lanes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Lanes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Lanes& from);
  void MergeFrom(const Lanes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lanes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .adam.map.LaneSection lane_section = 1;
  bool has_lane_section() const;
  void clear_lane_section();
  static const int kLaneSectionFieldNumber = 1;
  private:
  const ::adam::map::LaneSection& _internal_lane_section() const;
  public:
  const ::adam::map::LaneSection& lane_section() const;
  ::adam::map::LaneSection* release_lane_section();
  ::adam::map::LaneSection* mutable_lane_section();
  void set_allocated_lane_section(::adam::map::LaneSection* lane_section);

  // @@protoc_insertion_point(class_scope:adam.map.Lanes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::adam::map::LaneSection* lane_section_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.LaneSet) */ {
 public:
  LaneSet();
  virtual ~LaneSet();

  LaneSet(const LaneSet& from);

  inline LaneSet& operator=(const LaneSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneSet(LaneSet&& from) noexcept
    : LaneSet() {
    *this = ::std::move(from);
  }

  inline LaneSet& operator=(LaneSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneSet* internal_default_instance() {
    return reinterpret_cast<const LaneSet*>(
               &_LaneSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(LaneSet* other);
  friend void swap(LaneSet& a, LaneSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneSet* New() const final {
    return CreateMaybeMessage<LaneSet>(NULL);
  }

  LaneSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneSet& from);
  void MergeFrom(const LaneSet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .adam.map.Lane lane = 1;
  int lane_size() const;
  void clear_lane();
  static const int kLaneFieldNumber = 1;
  ::adam::map::Lane* mutable_lane(int index);
  ::google::protobuf::RepeatedPtrField< ::adam::map::Lane >*
      mutable_lane();
  const ::adam::map::Lane& lane(int index) const;
  ::adam::map::Lane* add_lane();
  const ::google::protobuf::RepeatedPtrField< ::adam::map::Lane >&
      lane() const;

  // @@protoc_insertion_point(class_scope:adam.map.LaneSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::adam::map::Lane > lane_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Lane* other);
  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const final {
    return CreateMaybeMessage<Lane>(NULL);
  }

  Lane* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .adam.map.RoadMark road_mark = 5;
  int road_mark_size() const;
  void clear_road_mark();
  static const int kRoadMarkFieldNumber = 5;
  ::adam::map::RoadMark* mutable_road_mark(int index);
  ::google::protobuf::RepeatedPtrField< ::adam::map::RoadMark >*
      mutable_road_mark();
  const ::adam::map::RoadMark& road_mark(int index) const;
  ::adam::map::RoadMark* add_road_mark();
  const ::google::protobuf::RepeatedPtrField< ::adam::map::RoadMark >&
      road_mark() const;

  // .adam.map.LaneWidth width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  private:
  const ::adam::map::LaneWidth& _internal_width() const;
  public:
  const ::adam::map::LaneWidth& width() const;
  ::adam::map::LaneWidth* release_width();
  ::adam::map::LaneWidth* mutable_width();
  void set_allocated_width(::adam::map::LaneWidth* width);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:adam.map.Lane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::adam::map::RoadMark > road_mark_;
  ::adam::map::LaneWidth* width_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadMark : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.RoadMark) */ {
 public:
  RoadMark();
  virtual ~RoadMark();

  RoadMark(const RoadMark& from);

  inline RoadMark& operator=(const RoadMark& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadMark(RoadMark&& from) noexcept
    : RoadMark() {
    *this = ::std::move(from);
  }

  inline RoadMark& operator=(RoadMark&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadMark& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadMark* internal_default_instance() {
    return reinterpret_cast<const RoadMark*>(
               &_RoadMark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RoadMark* other);
  friend void swap(RoadMark& a, RoadMark& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadMark* New() const final {
    return CreateMaybeMessage<RoadMark>(NULL);
  }

  RoadMark* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadMark>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadMark& from);
  void MergeFrom(const RoadMark& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadMark* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string color = 4;
  void clear_color();
  static const int kColorFieldNumber = 4;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  #if LANG_CXX11
  void set_color(::std::string&& value);
  #endif
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // double width = 6;
  void clear_width();
  static const int kWidthFieldNumber = 6;
  double width() const;
  void set_width(double value);

  // @@protoc_insertion_point(class_scope:adam.map.RoadMark)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr color_;
  double width_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneWidth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.LaneWidth) */ {
 public:
  LaneWidth();
  virtual ~LaneWidth();

  LaneWidth(const LaneWidth& from);

  inline LaneWidth& operator=(const LaneWidth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneWidth(LaneWidth&& from) noexcept
    : LaneWidth() {
    *this = ::std::move(from);
  }

  inline LaneWidth& operator=(LaneWidth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneWidth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneWidth* internal_default_instance() {
    return reinterpret_cast<const LaneWidth*>(
               &_LaneWidth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(LaneWidth* other);
  friend void swap(LaneWidth& a, LaneWidth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneWidth* New() const final {
    return CreateMaybeMessage<LaneWidth>(NULL);
  }

  LaneWidth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneWidth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneWidth& from);
  void MergeFrom(const LaneWidth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneWidth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double s_offset = 1;
  void clear_s_offset();
  static const int kSOffsetFieldNumber = 1;
  double s_offset() const;
  void set_s_offset(double value);

  // double a = 2;
  void clear_a();
  static const int kAFieldNumber = 2;
  double a() const;
  void set_a(double value);

  // double b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  double b() const;
  void set_b(double value);

  // double c = 4;
  void clear_c();
  static const int kCFieldNumber = 4;
  double c() const;
  void set_c(double value);

  // double d = 5;
  void clear_d();
  static const int kDFieldNumber = 5;
  double d() const;
  void set_d(double value);

  // @@protoc_insertion_point(class_scope:adam.map.LaneWidth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double s_offset_;
  double a_;
  double b_;
  double c_;
  double d_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneSection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.LaneSection) */ {
 public:
  LaneSection();
  virtual ~LaneSection();

  LaneSection(const LaneSection& from);

  inline LaneSection& operator=(const LaneSection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneSection(LaneSection&& from) noexcept
    : LaneSection() {
    *this = ::std::move(from);
  }

  inline LaneSection& operator=(LaneSection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneSection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneSection* internal_default_instance() {
    return reinterpret_cast<const LaneSection*>(
               &_LaneSection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(LaneSection* other);
  friend void swap(LaneSection& a, LaneSection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneSection* New() const final {
    return CreateMaybeMessage<LaneSection>(NULL);
  }

  LaneSection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneSection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneSection& from);
  void MergeFrom(const LaneSection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneSection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .adam.map.LaneSet left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  private:
  const ::adam::map::LaneSet& _internal_left() const;
  public:
  const ::adam::map::LaneSet& left() const;
  ::adam::map::LaneSet* release_left();
  ::adam::map::LaneSet* mutable_left();
  void set_allocated_left(::adam::map::LaneSet* left);

  // .adam.map.LaneSet center = 3;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 3;
  private:
  const ::adam::map::LaneSet& _internal_center() const;
  public:
  const ::adam::map::LaneSet& center() const;
  ::adam::map::LaneSet* release_center();
  ::adam::map::LaneSet* mutable_center();
  void set_allocated_center(::adam::map::LaneSet* center);

  // .adam.map.LaneSet right = 4;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 4;
  private:
  const ::adam::map::LaneSet& _internal_right() const;
  public:
  const ::adam::map::LaneSet& right() const;
  ::adam::map::LaneSet* release_right();
  ::adam::map::LaneSet* mutable_right();
  void set_allocated_right(::adam::map::LaneSet* right);

  // double s = 1;
  void clear_s();
  static const int kSFieldNumber = 1;
  double s() const;
  void set_s(double value);

  // @@protoc_insertion_point(class_scope:adam.map.LaneSection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::adam::map::LaneSet* left_;
  ::adam::map::LaneSet* center_;
  ::adam::map::LaneSet* right_;
  double s_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Junction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Junction) */ {
 public:
  Junction();
  virtual ~Junction();

  Junction(const Junction& from);

  inline Junction& operator=(const Junction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Junction(Junction&& from) noexcept
    : Junction() {
    *this = ::std::move(from);
  }

  inline Junction& operator=(Junction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Junction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Junction* internal_default_instance() {
    return reinterpret_cast<const Junction*>(
               &_Junction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Junction* other);
  friend void swap(Junction& a, Junction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Junction* New() const final {
    return CreateMaybeMessage<Junction>(NULL);
  }

  Junction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Junction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Junction& from);
  void MergeFrom(const Junction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Junction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .adam.map.Connection connection = 3;
  int connection_size() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 3;
  ::adam::map::Connection* mutable_connection(int index);
  ::google::protobuf::RepeatedPtrField< ::adam::map::Connection >*
      mutable_connection();
  const ::adam::map::Connection& connection(int index) const;
  ::adam::map::Connection* add_connection();
  const ::google::protobuf::RepeatedPtrField< ::adam::map::Connection >&
      connection() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:adam.map.Junction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::adam::map::Connection > connection_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Connection) */ {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Connection(Connection&& from) noexcept
    : Connection() {
    *this = ::std::move(from);
  }

  inline Connection& operator=(Connection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Connection* other);
  friend void swap(Connection& a, Connection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Connection* New() const final {
    return CreateMaybeMessage<Connection>(NULL);
  }

  Connection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Connection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .adam.map.ConnectionLaneLink lane_link = 5;
  int lane_link_size() const;
  void clear_lane_link();
  static const int kLaneLinkFieldNumber = 5;
  ::adam::map::ConnectionLaneLink* mutable_lane_link(int index);
  ::google::protobuf::RepeatedPtrField< ::adam::map::ConnectionLaneLink >*
      mutable_lane_link();
  const ::adam::map::ConnectionLaneLink& lane_link(int index) const;
  ::adam::map::ConnectionLaneLink* add_lane_link();
  const ::google::protobuf::RepeatedPtrField< ::adam::map::ConnectionLaneLink >&
      lane_link() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string incoming_road = 2;
  void clear_incoming_road();
  static const int kIncomingRoadFieldNumber = 2;
  const ::std::string& incoming_road() const;
  void set_incoming_road(const ::std::string& value);
  #if LANG_CXX11
  void set_incoming_road(::std::string&& value);
  #endif
  void set_incoming_road(const char* value);
  void set_incoming_road(const char* value, size_t size);
  ::std::string* mutable_incoming_road();
  ::std::string* release_incoming_road();
  void set_allocated_incoming_road(::std::string* incoming_road);

  // string connecting_road = 3;
  void clear_connecting_road();
  static const int kConnectingRoadFieldNumber = 3;
  const ::std::string& connecting_road() const;
  void set_connecting_road(const ::std::string& value);
  #if LANG_CXX11
  void set_connecting_road(::std::string&& value);
  #endif
  void set_connecting_road(const char* value);
  void set_connecting_road(const char* value, size_t size);
  ::std::string* mutable_connecting_road();
  ::std::string* release_connecting_road();
  void set_allocated_connecting_road(::std::string* connecting_road);

  // string contact_point = 4;
  void clear_contact_point();
  static const int kContactPointFieldNumber = 4;
  const ::std::string& contact_point() const;
  void set_contact_point(const ::std::string& value);
  #if LANG_CXX11
  void set_contact_point(::std::string&& value);
  #endif
  void set_contact_point(const char* value);
  void set_contact_point(const char* value, size_t size);
  ::std::string* mutable_contact_point();
  ::std::string* release_contact_point();
  void set_allocated_contact_point(::std::string* contact_point);

  // @@protoc_insertion_point(class_scope:adam.map.Connection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::adam::map::ConnectionLaneLink > lane_link_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr incoming_road_;
  ::google::protobuf::internal::ArenaStringPtr connecting_road_;
  ::google::protobuf::internal::ArenaStringPtr contact_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectionLaneLink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.ConnectionLaneLink) */ {
 public:
  ConnectionLaneLink();
  virtual ~ConnectionLaneLink();

  ConnectionLaneLink(const ConnectionLaneLink& from);

  inline ConnectionLaneLink& operator=(const ConnectionLaneLink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionLaneLink(ConnectionLaneLink&& from) noexcept
    : ConnectionLaneLink() {
    *this = ::std::move(from);
  }

  inline ConnectionLaneLink& operator=(ConnectionLaneLink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionLaneLink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionLaneLink* internal_default_instance() {
    return reinterpret_cast<const ConnectionLaneLink*>(
               &_ConnectionLaneLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ConnectionLaneLink* other);
  friend void swap(ConnectionLaneLink& a, ConnectionLaneLink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionLaneLink* New() const final {
    return CreateMaybeMessage<ConnectionLaneLink>(NULL);
  }

  ConnectionLaneLink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionLaneLink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionLaneLink& from);
  void MergeFrom(const ConnectionLaneLink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionLaneLink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  ::google::protobuf::int32 from() const;
  void set_from(::google::protobuf::int32 value);

  // int32 to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  ::google::protobuf::int32 to() const;
  void set_to(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:adam.map.ConnectionLaneLink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::int32 to_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadLink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.RoadLink) */ {
 public:
  RoadLink();
  virtual ~RoadLink();

  RoadLink(const RoadLink& from);

  inline RoadLink& operator=(const RoadLink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadLink(RoadLink&& from) noexcept
    : RoadLink() {
    *this = ::std::move(from);
  }

  inline RoadLink& operator=(RoadLink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadLink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadLink* internal_default_instance() {
    return reinterpret_cast<const RoadLink*>(
               &_RoadLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RoadLink* other);
  friend void swap(RoadLink& a, RoadLink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadLink* New() const final {
    return CreateMaybeMessage<RoadLink>(NULL);
  }

  RoadLink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadLink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadLink& from);
  void MergeFrom(const RoadLink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadLink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .adam.map.RoadLinker predecessor = 1;
  bool has_predecessor() const;
  void clear_predecessor();
  static const int kPredecessorFieldNumber = 1;
  private:
  const ::adam::map::RoadLinker& _internal_predecessor() const;
  public:
  const ::adam::map::RoadLinker& predecessor() const;
  ::adam::map::RoadLinker* release_predecessor();
  ::adam::map::RoadLinker* mutable_predecessor();
  void set_allocated_predecessor(::adam::map::RoadLinker* predecessor);

  // .adam.map.RoadLinker successor = 2;
  bool has_successor() const;
  void clear_successor();
  static const int kSuccessorFieldNumber = 2;
  private:
  const ::adam::map::RoadLinker& _internal_successor() const;
  public:
  const ::adam::map::RoadLinker& successor() const;
  ::adam::map::RoadLinker* release_successor();
  ::adam::map::RoadLinker* mutable_successor();
  void set_allocated_successor(::adam::map::RoadLinker* successor);

  // @@protoc_insertion_point(class_scope:adam.map.RoadLink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::adam::map::RoadLinker* predecessor_;
  ::adam::map::RoadLinker* successor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadLinker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.RoadLinker) */ {
 public:
  RoadLinker();
  virtual ~RoadLinker();

  RoadLinker(const RoadLinker& from);

  inline RoadLinker& operator=(const RoadLinker& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadLinker(RoadLinker&& from) noexcept
    : RoadLinker() {
    *this = ::std::move(from);
  }

  inline RoadLinker& operator=(RoadLinker&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadLinker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadLinker* internal_default_instance() {
    return reinterpret_cast<const RoadLinker*>(
               &_RoadLinker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RoadLinker* other);
  friend void swap(RoadLinker& a, RoadLinker& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadLinker* New() const final {
    return CreateMaybeMessage<RoadLinker>(NULL);
  }

  RoadLinker* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadLinker>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadLinker& from);
  void MergeFrom(const RoadLinker& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadLinker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string element_type = 1;
  void clear_element_type();
  static const int kElementTypeFieldNumber = 1;
  const ::std::string& element_type() const;
  void set_element_type(const ::std::string& value);
  #if LANG_CXX11
  void set_element_type(::std::string&& value);
  #endif
  void set_element_type(const char* value);
  void set_element_type(const char* value, size_t size);
  ::std::string* mutable_element_type();
  ::std::string* release_element_type();
  void set_allocated_element_type(::std::string* element_type);

  // string element_id = 2;
  void clear_element_id();
  static const int kElementIdFieldNumber = 2;
  const ::std::string& element_id() const;
  void set_element_id(const ::std::string& value);
  #if LANG_CXX11
  void set_element_id(::std::string&& value);
  #endif
  void set_element_id(const char* value);
  void set_element_id(const char* value, size_t size);
  ::std::string* mutable_element_id();
  ::std::string* release_element_id();
  void set_allocated_element_id(::std::string* element_id);

  // string contact_point = 3;
  void clear_contact_point();
  static const int kContactPointFieldNumber = 3;
  const ::std::string& contact_point() const;
  void set_contact_point(const ::std::string& value);
  #if LANG_CXX11
  void set_contact_point(::std::string&& value);
  #endif
  void set_contact_point(const char* value);
  void set_contact_point(const char* value, size_t size);
  ::std::string* mutable_contact_point();
  ::std::string* release_contact_point();
  void set_allocated_contact_point(::std::string* contact_point);

  // @@protoc_insertion_point(class_scope:adam.map.RoadLinker)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr element_type_;
  ::google::protobuf::internal::ArenaStringPtr element_id_;
  ::google::protobuf::internal::ArenaStringPtr contact_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Road : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Road) */ {
 public:
  Road();
  virtual ~Road();

  Road(const Road& from);

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(Road&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Road& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Road* other);
  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Road* New() const final {
    return CreateMaybeMessage<Road>(NULL);
  }

  Road* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Road>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Road& from);
  void MergeFrom(const Road& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Road* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .adam.map.Lanes lanes = 9;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 9;
  ::adam::map::Lanes* mutable_lanes(int index);
  ::google::protobuf::RepeatedPtrField< ::adam::map::Lanes >*
      mutable_lanes();
  const ::adam::map::Lanes& lanes(int index) const;
  ::adam::map::Lanes* add_lanes();
  const ::google::protobuf::RepeatedPtrField< ::adam::map::Lanes >&
      lanes() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .adam.map.RoadLink link = 5;
  bool has_link() const;
  void clear_link();
  static const int kLinkFieldNumber = 5;
  private:
  const ::adam::map::RoadLink& _internal_link() const;
  public:
  const ::adam::map::RoadLink& link() const;
  ::adam::map::RoadLink* release_link();
  ::adam::map::RoadLink* mutable_link();
  void set_allocated_link(::adam::map::RoadLink* link);

  // .adam.map.PlainView plain_view = 6;
  bool has_plain_view() const;
  void clear_plain_view();
  static const int kPlainViewFieldNumber = 6;
  private:
  const ::adam::map::PlainView& _internal_plain_view() const;
  public:
  const ::adam::map::PlainView& plain_view() const;
  ::adam::map::PlainView* release_plain_view();
  ::adam::map::PlainView* mutable_plain_view();
  void set_allocated_plain_view(::adam::map::PlainView* plain_view);

  // @@protoc_insertion_point(class_scope:adam.map.Road)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::adam::map::Lanes > lanes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::adam::map::RoadLink* link_;
  ::adam::map::PlainView* plain_view_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class A : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.A) */ {
 public:
  A();
  virtual ~A();

  A(const A& from);

  inline A& operator=(const A& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  A(A&& from) noexcept
    : A() {
    *this = ::std::move(from);
  }

  inline A& operator=(A&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const A& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const A* internal_default_instance() {
    return reinterpret_cast<const A*>(
               &_A_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(A* other);
  friend void swap(A& a, A& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline A* New() const final {
    return CreateMaybeMessage<A>(NULL);
  }

  A* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<A>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const A& from);
  void MergeFrom(const A& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(A* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:adam.map.A)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class B : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.B) */ {
 public:
  B();
  virtual ~B();

  B(const B& from);

  inline B& operator=(const B& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  B(B&& from) noexcept
    : B() {
    *this = ::std::move(from);
  }

  inline B& operator=(B&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const B& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const B* internal_default_instance() {
    return reinterpret_cast<const B*>(
               &_B_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(B* other);
  friend void swap(B& a, B& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline B* New() const final {
    return CreateMaybeMessage<B>(NULL);
  }

  B* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<B>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const B& from);
  void MergeFrom(const B& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(B* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:adam.map.B)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:adam.map.Map) */ {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Map(Map&& from) noexcept
    : Map() {
    *this = ::std::move(from);
  }

  inline Map& operator=(Map&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Map* internal_default_instance() {
    return reinterpret_cast<const Map*>(
               &_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Map* other);
  friend void swap(Map& a, Map& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Map* New() const final {
    return CreateMaybeMessage<Map>(NULL);
  }

  Map* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Map>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .adam.map.Road road = 2;
  int road_size() const;
  void clear_road();
  static const int kRoadFieldNumber = 2;
  ::adam::map::Road* mutable_road(int index);
  ::google::protobuf::RepeatedPtrField< ::adam::map::Road >*
      mutable_road();
  const ::adam::map::Road& road(int index) const;
  ::adam::map::Road* add_road();
  const ::google::protobuf::RepeatedPtrField< ::adam::map::Road >&
      road() const;

  // repeated .adam.map.Junction junction = 3;
  int junction_size() const;
  void clear_junction();
  static const int kJunctionFieldNumber = 3;
  ::adam::map::Junction* mutable_junction(int index);
  ::google::protobuf::RepeatedPtrField< ::adam::map::Junction >*
      mutable_junction();
  const ::adam::map::Junction& junction(int index) const;
  ::adam::map::Junction* add_junction();
  const ::google::protobuf::RepeatedPtrField< ::adam::map::Junction >&
      junction() const;

  // .adam.map.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::adam::map::Header& _internal_header() const;
  public:
  const ::adam::map::Header& header() const;
  ::adam::map::Header* release_header();
  ::adam::map::Header* mutable_header();
  void set_allocated_header(::adam::map::Header* header);

  // @@protoc_insertion_point(class_scope:adam.map.Map)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::adam::map::Road > road_;
  ::google::protobuf::RepeatedPtrField< ::adam::map::Junction > junction_;
  ::adam::map::Header* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fmap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// float version = 3;
inline void Header::clear_version() {
  version_ = 0;
}
inline float Header::version() const {
  // @@protoc_insertion_point(field_get:adam.map.Header.version)
  return version_;
}
inline void Header::set_version(float value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:adam.map.Header.version)
}

// string name = 4;
inline void Header::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::name() const {
  // @@protoc_insertion_point(field_get:adam.map.Header.name)
  return name_.GetNoArena();
}
inline void Header::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Header.name)
}
#if LANG_CXX11
inline void Header::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Header.name)
}
#endif
inline void Header::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Header.name)
}
inline void Header::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Header.name)
}
inline ::std::string* Header::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Header.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_name() {
  // @@protoc_insertion_point(field_release:adam.map.Header.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Header.name)
}

// string date = 5;
inline void Header::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::date() const {
  // @@protoc_insertion_point(field_get:adam.map.Header.date)
  return date_.GetNoArena();
}
inline void Header::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Header.date)
}
#if LANG_CXX11
inline void Header::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Header.date)
}
#endif
inline void Header::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Header.date)
}
inline void Header::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Header.date)
}
inline ::std::string* Header::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Header.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_date() {
  // @@protoc_insertion_point(field_release:adam.map.Header.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Header.date)
}

// -------------------------------------------------------------------

// Geometry

// double s = 1;
inline void Geometry::clear_s() {
  s_ = 0;
}
inline double Geometry::s() const {
  // @@protoc_insertion_point(field_get:adam.map.Geometry.s)
  return s_;
}
inline void Geometry::set_s(double value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:adam.map.Geometry.s)
}

// double x = 2;
inline void Geometry::clear_x() {
  x_ = 0;
}
inline double Geometry::x() const {
  // @@protoc_insertion_point(field_get:adam.map.Geometry.x)
  return x_;
}
inline void Geometry::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:adam.map.Geometry.x)
}

// double y = 3;
inline void Geometry::clear_y() {
  y_ = 0;
}
inline double Geometry::y() const {
  // @@protoc_insertion_point(field_get:adam.map.Geometry.y)
  return y_;
}
inline void Geometry::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:adam.map.Geometry.y)
}

// double hdg = 4;
inline void Geometry::clear_hdg() {
  hdg_ = 0;
}
inline double Geometry::hdg() const {
  // @@protoc_insertion_point(field_get:adam.map.Geometry.hdg)
  return hdg_;
}
inline void Geometry::set_hdg(double value) {
  
  hdg_ = value;
  // @@protoc_insertion_point(field_set:adam.map.Geometry.hdg)
}

// double length = 5;
inline void Geometry::clear_length() {
  length_ = 0;
}
inline double Geometry::length() const {
  // @@protoc_insertion_point(field_get:adam.map.Geometry.length)
  return length_;
}
inline void Geometry::set_length(double value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:adam.map.Geometry.length)
}

// .adam.map.Line line = 6;
inline bool Geometry::has_line() const {
  return shape_case() == kLine;
}
inline void Geometry::set_has_line() {
  _oneof_case_[0] = kLine;
}
inline void Geometry::clear_line() {
  if (has_line()) {
    delete shape_.line_;
    clear_has_shape();
  }
}
inline const ::adam::map::Line& Geometry::_internal_line() const {
  return *shape_.line_;
}
inline ::adam::map::Line* Geometry::release_line() {
  // @@protoc_insertion_point(field_release:adam.map.Geometry.line)
  if (has_line()) {
    clear_has_shape();
      ::adam::map::Line* temp = shape_.line_;
    shape_.line_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::adam::map::Line& Geometry::line() const {
  // @@protoc_insertion_point(field_get:adam.map.Geometry.line)
  return has_line()
      ? *shape_.line_
      : *reinterpret_cast< ::adam::map::Line*>(&::adam::map::_Line_default_instance_);
}
inline ::adam::map::Line* Geometry::mutable_line() {
  if (!has_line()) {
    clear_shape();
    set_has_line();
    shape_.line_ = CreateMaybeMessage< ::adam::map::Line >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:adam.map.Geometry.line)
  return shape_.line_;
}

// .adam.map.Arc arc = 7;
inline bool Geometry::has_arc() const {
  return shape_case() == kArc;
}
inline void Geometry::set_has_arc() {
  _oneof_case_[0] = kArc;
}
inline void Geometry::clear_arc() {
  if (has_arc()) {
    delete shape_.arc_;
    clear_has_shape();
  }
}
inline const ::adam::map::Arc& Geometry::_internal_arc() const {
  return *shape_.arc_;
}
inline ::adam::map::Arc* Geometry::release_arc() {
  // @@protoc_insertion_point(field_release:adam.map.Geometry.arc)
  if (has_arc()) {
    clear_has_shape();
      ::adam::map::Arc* temp = shape_.arc_;
    shape_.arc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::adam::map::Arc& Geometry::arc() const {
  // @@protoc_insertion_point(field_get:adam.map.Geometry.arc)
  return has_arc()
      ? *shape_.arc_
      : *reinterpret_cast< ::adam::map::Arc*>(&::adam::map::_Arc_default_instance_);
}
inline ::adam::map::Arc* Geometry::mutable_arc() {
  if (!has_arc()) {
    clear_shape();
    set_has_arc();
    shape_.arc_ = CreateMaybeMessage< ::adam::map::Arc >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:adam.map.Geometry.arc)
  return shape_.arc_;
}

inline bool Geometry::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void Geometry::clear_has_shape() {
  _oneof_case_[0] = SHAPE_NOT_SET;
}
inline Geometry::ShapeCase Geometry::shape_case() const {
  return Geometry::ShapeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Line

// -------------------------------------------------------------------

// Arc

// double curvature = 1;
inline void Arc::clear_curvature() {
  curvature_ = 0;
}
inline double Arc::curvature() const {
  // @@protoc_insertion_point(field_get:adam.map.Arc.curvature)
  return curvature_;
}
inline void Arc::set_curvature(double value) {
  
  curvature_ = value;
  // @@protoc_insertion_point(field_set:adam.map.Arc.curvature)
}

// -------------------------------------------------------------------

// PlainView

// repeated .adam.map.Geometry geometry = 1;
inline int PlainView::geometry_size() const {
  return geometry_.size();
}
inline void PlainView::clear_geometry() {
  geometry_.Clear();
}
inline ::adam::map::Geometry* PlainView::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:adam.map.PlainView.geometry)
  return geometry_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::adam::map::Geometry >*
PlainView::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:adam.map.PlainView.geometry)
  return &geometry_;
}
inline const ::adam::map::Geometry& PlainView::geometry(int index) const {
  // @@protoc_insertion_point(field_get:adam.map.PlainView.geometry)
  return geometry_.Get(index);
}
inline ::adam::map::Geometry* PlainView::add_geometry() {
  // @@protoc_insertion_point(field_add:adam.map.PlainView.geometry)
  return geometry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::adam::map::Geometry >&
PlainView::geometry() const {
  // @@protoc_insertion_point(field_list:adam.map.PlainView.geometry)
  return geometry_;
}

// -------------------------------------------------------------------

// Lanes

// .adam.map.LaneSection lane_section = 1;
inline bool Lanes::has_lane_section() const {
  return this != internal_default_instance() && lane_section_ != NULL;
}
inline void Lanes::clear_lane_section() {
  if (GetArenaNoVirtual() == NULL && lane_section_ != NULL) {
    delete lane_section_;
  }
  lane_section_ = NULL;
}
inline const ::adam::map::LaneSection& Lanes::_internal_lane_section() const {
  return *lane_section_;
}
inline const ::adam::map::LaneSection& Lanes::lane_section() const {
  const ::adam::map::LaneSection* p = lane_section_;
  // @@protoc_insertion_point(field_get:adam.map.Lanes.lane_section)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::LaneSection*>(
      &::adam::map::_LaneSection_default_instance_);
}
inline ::adam::map::LaneSection* Lanes::release_lane_section() {
  // @@protoc_insertion_point(field_release:adam.map.Lanes.lane_section)
  
  ::adam::map::LaneSection* temp = lane_section_;
  lane_section_ = NULL;
  return temp;
}
inline ::adam::map::LaneSection* Lanes::mutable_lane_section() {
  
  if (lane_section_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::LaneSection>(GetArenaNoVirtual());
    lane_section_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.Lanes.lane_section)
  return lane_section_;
}
inline void Lanes::set_allocated_lane_section(::adam::map::LaneSection* lane_section) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lane_section_;
  }
  if (lane_section) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane_section = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_section, submessage_arena);
    }
    
  } else {
    
  }
  lane_section_ = lane_section;
  // @@protoc_insertion_point(field_set_allocated:adam.map.Lanes.lane_section)
}

// -------------------------------------------------------------------

// LaneSet

// repeated .adam.map.Lane lane = 1;
inline int LaneSet::lane_size() const {
  return lane_.size();
}
inline void LaneSet::clear_lane() {
  lane_.Clear();
}
inline ::adam::map::Lane* LaneSet::mutable_lane(int index) {
  // @@protoc_insertion_point(field_mutable:adam.map.LaneSet.lane)
  return lane_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::adam::map::Lane >*
LaneSet::mutable_lane() {
  // @@protoc_insertion_point(field_mutable_list:adam.map.LaneSet.lane)
  return &lane_;
}
inline const ::adam::map::Lane& LaneSet::lane(int index) const {
  // @@protoc_insertion_point(field_get:adam.map.LaneSet.lane)
  return lane_.Get(index);
}
inline ::adam::map::Lane* LaneSet::add_lane() {
  // @@protoc_insertion_point(field_add:adam.map.LaneSet.lane)
  return lane_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::adam::map::Lane >&
LaneSet::lane() const {
  // @@protoc_insertion_point(field_list:adam.map.LaneSet.lane)
  return lane_;
}

// -------------------------------------------------------------------

// Lane

// int32 id = 1;
inline void Lane::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Lane::id() const {
  // @@protoc_insertion_point(field_get:adam.map.Lane.id)
  return id_;
}
inline void Lane::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:adam.map.Lane.id)
}

// .adam.map.LaneWidth width = 4;
inline bool Lane::has_width() const {
  return this != internal_default_instance() && width_ != NULL;
}
inline void Lane::clear_width() {
  if (GetArenaNoVirtual() == NULL && width_ != NULL) {
    delete width_;
  }
  width_ = NULL;
}
inline const ::adam::map::LaneWidth& Lane::_internal_width() const {
  return *width_;
}
inline const ::adam::map::LaneWidth& Lane::width() const {
  const ::adam::map::LaneWidth* p = width_;
  // @@protoc_insertion_point(field_get:adam.map.Lane.width)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::LaneWidth*>(
      &::adam::map::_LaneWidth_default_instance_);
}
inline ::adam::map::LaneWidth* Lane::release_width() {
  // @@protoc_insertion_point(field_release:adam.map.Lane.width)
  
  ::adam::map::LaneWidth* temp = width_;
  width_ = NULL;
  return temp;
}
inline ::adam::map::LaneWidth* Lane::mutable_width() {
  
  if (width_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::LaneWidth>(GetArenaNoVirtual());
    width_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.Lane.width)
  return width_;
}
inline void Lane::set_allocated_width(::adam::map::LaneWidth* width) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete width_;
  }
  if (width) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      width = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, width, submessage_arena);
    }
    
  } else {
    
  }
  width_ = width;
  // @@protoc_insertion_point(field_set_allocated:adam.map.Lane.width)
}

// repeated .adam.map.RoadMark road_mark = 5;
inline int Lane::road_mark_size() const {
  return road_mark_.size();
}
inline void Lane::clear_road_mark() {
  road_mark_.Clear();
}
inline ::adam::map::RoadMark* Lane::mutable_road_mark(int index) {
  // @@protoc_insertion_point(field_mutable:adam.map.Lane.road_mark)
  return road_mark_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::adam::map::RoadMark >*
Lane::mutable_road_mark() {
  // @@protoc_insertion_point(field_mutable_list:adam.map.Lane.road_mark)
  return &road_mark_;
}
inline const ::adam::map::RoadMark& Lane::road_mark(int index) const {
  // @@protoc_insertion_point(field_get:adam.map.Lane.road_mark)
  return road_mark_.Get(index);
}
inline ::adam::map::RoadMark* Lane::add_road_mark() {
  // @@protoc_insertion_point(field_add:adam.map.Lane.road_mark)
  return road_mark_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::adam::map::RoadMark >&
Lane::road_mark() const {
  // @@protoc_insertion_point(field_list:adam.map.Lane.road_mark)
  return road_mark_;
}

// -------------------------------------------------------------------

// RoadMark

// string type = 2;
inline void RoadMark::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadMark::type() const {
  // @@protoc_insertion_point(field_get:adam.map.RoadMark.type)
  return type_.GetNoArena();
}
inline void RoadMark::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.RoadMark.type)
}
#if LANG_CXX11
inline void RoadMark::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.RoadMark.type)
}
#endif
inline void RoadMark::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.RoadMark.type)
}
inline void RoadMark::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.RoadMark.type)
}
inline ::std::string* RoadMark::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.RoadMark.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadMark::release_type() {
  // @@protoc_insertion_point(field_release:adam.map.RoadMark.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadMark::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:adam.map.RoadMark.type)
}

// string color = 4;
inline void RoadMark::clear_color() {
  color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadMark::color() const {
  // @@protoc_insertion_point(field_get:adam.map.RoadMark.color)
  return color_.GetNoArena();
}
inline void RoadMark::set_color(const ::std::string& value) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.RoadMark.color)
}
#if LANG_CXX11
inline void RoadMark::set_color(::std::string&& value) {
  
  color_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.RoadMark.color)
}
#endif
inline void RoadMark::set_color(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.RoadMark.color)
}
inline void RoadMark::set_color(const char* value, size_t size) {
  
  color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.RoadMark.color)
}
inline ::std::string* RoadMark::mutable_color() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.RoadMark.color)
  return color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadMark::release_color() {
  // @@protoc_insertion_point(field_release:adam.map.RoadMark.color)
  
  return color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadMark::set_allocated_color(::std::string* color) {
  if (color != NULL) {
    
  } else {
    
  }
  color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), color);
  // @@protoc_insertion_point(field_set_allocated:adam.map.RoadMark.color)
}

// double width = 6;
inline void RoadMark::clear_width() {
  width_ = 0;
}
inline double RoadMark::width() const {
  // @@protoc_insertion_point(field_get:adam.map.RoadMark.width)
  return width_;
}
inline void RoadMark::set_width(double value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:adam.map.RoadMark.width)
}

// -------------------------------------------------------------------

// LaneWidth

// double s_offset = 1;
inline void LaneWidth::clear_s_offset() {
  s_offset_ = 0;
}
inline double LaneWidth::s_offset() const {
  // @@protoc_insertion_point(field_get:adam.map.LaneWidth.s_offset)
  return s_offset_;
}
inline void LaneWidth::set_s_offset(double value) {
  
  s_offset_ = value;
  // @@protoc_insertion_point(field_set:adam.map.LaneWidth.s_offset)
}

// double a = 2;
inline void LaneWidth::clear_a() {
  a_ = 0;
}
inline double LaneWidth::a() const {
  // @@protoc_insertion_point(field_get:adam.map.LaneWidth.a)
  return a_;
}
inline void LaneWidth::set_a(double value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:adam.map.LaneWidth.a)
}

// double b = 3;
inline void LaneWidth::clear_b() {
  b_ = 0;
}
inline double LaneWidth::b() const {
  // @@protoc_insertion_point(field_get:adam.map.LaneWidth.b)
  return b_;
}
inline void LaneWidth::set_b(double value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:adam.map.LaneWidth.b)
}

// double c = 4;
inline void LaneWidth::clear_c() {
  c_ = 0;
}
inline double LaneWidth::c() const {
  // @@protoc_insertion_point(field_get:adam.map.LaneWidth.c)
  return c_;
}
inline void LaneWidth::set_c(double value) {
  
  c_ = value;
  // @@protoc_insertion_point(field_set:adam.map.LaneWidth.c)
}

// double d = 5;
inline void LaneWidth::clear_d() {
  d_ = 0;
}
inline double LaneWidth::d() const {
  // @@protoc_insertion_point(field_get:adam.map.LaneWidth.d)
  return d_;
}
inline void LaneWidth::set_d(double value) {
  
  d_ = value;
  // @@protoc_insertion_point(field_set:adam.map.LaneWidth.d)
}

// -------------------------------------------------------------------

// LaneSection

// double s = 1;
inline void LaneSection::clear_s() {
  s_ = 0;
}
inline double LaneSection::s() const {
  // @@protoc_insertion_point(field_get:adam.map.LaneSection.s)
  return s_;
}
inline void LaneSection::set_s(double value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:adam.map.LaneSection.s)
}

// .adam.map.LaneSet left = 2;
inline bool LaneSection::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void LaneSection::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::adam::map::LaneSet& LaneSection::_internal_left() const {
  return *left_;
}
inline const ::adam::map::LaneSet& LaneSection::left() const {
  const ::adam::map::LaneSet* p = left_;
  // @@protoc_insertion_point(field_get:adam.map.LaneSection.left)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::LaneSet*>(
      &::adam::map::_LaneSet_default_instance_);
}
inline ::adam::map::LaneSet* LaneSection::release_left() {
  // @@protoc_insertion_point(field_release:adam.map.LaneSection.left)
  
  ::adam::map::LaneSet* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::adam::map::LaneSet* LaneSection::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::LaneSet>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.LaneSection.left)
  return left_;
}
inline void LaneSection::set_allocated_left(::adam::map::LaneSet* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:adam.map.LaneSection.left)
}

// .adam.map.LaneSet center = 3;
inline bool LaneSection::has_center() const {
  return this != internal_default_instance() && center_ != NULL;
}
inline void LaneSection::clear_center() {
  if (GetArenaNoVirtual() == NULL && center_ != NULL) {
    delete center_;
  }
  center_ = NULL;
}
inline const ::adam::map::LaneSet& LaneSection::_internal_center() const {
  return *center_;
}
inline const ::adam::map::LaneSet& LaneSection::center() const {
  const ::adam::map::LaneSet* p = center_;
  // @@protoc_insertion_point(field_get:adam.map.LaneSection.center)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::LaneSet*>(
      &::adam::map::_LaneSet_default_instance_);
}
inline ::adam::map::LaneSet* LaneSection::release_center() {
  // @@protoc_insertion_point(field_release:adam.map.LaneSection.center)
  
  ::adam::map::LaneSet* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::adam::map::LaneSet* LaneSection::mutable_center() {
  
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::LaneSet>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.LaneSection.center)
  return center_;
}
inline void LaneSection::set_allocated_center(::adam::map::LaneSet* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:adam.map.LaneSection.center)
}

// .adam.map.LaneSet right = 4;
inline bool LaneSection::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void LaneSection::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::adam::map::LaneSet& LaneSection::_internal_right() const {
  return *right_;
}
inline const ::adam::map::LaneSet& LaneSection::right() const {
  const ::adam::map::LaneSet* p = right_;
  // @@protoc_insertion_point(field_get:adam.map.LaneSection.right)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::LaneSet*>(
      &::adam::map::_LaneSet_default_instance_);
}
inline ::adam::map::LaneSet* LaneSection::release_right() {
  // @@protoc_insertion_point(field_release:adam.map.LaneSection.right)
  
  ::adam::map::LaneSet* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::adam::map::LaneSet* LaneSection::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::LaneSet>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.LaneSection.right)
  return right_;
}
inline void LaneSection::set_allocated_right(::adam::map::LaneSet* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:adam.map.LaneSection.right)
}

// -------------------------------------------------------------------

// Junction

// string name = 1;
inline void Junction::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Junction::name() const {
  // @@protoc_insertion_point(field_get:adam.map.Junction.name)
  return name_.GetNoArena();
}
inline void Junction::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Junction.name)
}
#if LANG_CXX11
inline void Junction::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Junction.name)
}
#endif
inline void Junction::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Junction.name)
}
inline void Junction::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Junction.name)
}
inline ::std::string* Junction::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Junction.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Junction::release_name() {
  // @@protoc_insertion_point(field_release:adam.map.Junction.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Junction::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Junction.name)
}

// string id = 2;
inline void Junction::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Junction::id() const {
  // @@protoc_insertion_point(field_get:adam.map.Junction.id)
  return id_.GetNoArena();
}
inline void Junction::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Junction.id)
}
#if LANG_CXX11
inline void Junction::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Junction.id)
}
#endif
inline void Junction::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Junction.id)
}
inline void Junction::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Junction.id)
}
inline ::std::string* Junction::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Junction.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Junction::release_id() {
  // @@protoc_insertion_point(field_release:adam.map.Junction.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Junction::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Junction.id)
}

// repeated .adam.map.Connection connection = 3;
inline int Junction::connection_size() const {
  return connection_.size();
}
inline void Junction::clear_connection() {
  connection_.Clear();
}
inline ::adam::map::Connection* Junction::mutable_connection(int index) {
  // @@protoc_insertion_point(field_mutable:adam.map.Junction.connection)
  return connection_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::adam::map::Connection >*
Junction::mutable_connection() {
  // @@protoc_insertion_point(field_mutable_list:adam.map.Junction.connection)
  return &connection_;
}
inline const ::adam::map::Connection& Junction::connection(int index) const {
  // @@protoc_insertion_point(field_get:adam.map.Junction.connection)
  return connection_.Get(index);
}
inline ::adam::map::Connection* Junction::add_connection() {
  // @@protoc_insertion_point(field_add:adam.map.Junction.connection)
  return connection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::adam::map::Connection >&
Junction::connection() const {
  // @@protoc_insertion_point(field_list:adam.map.Junction.connection)
  return connection_;
}

// -------------------------------------------------------------------

// Connection

// string id = 1;
inline void Connection::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connection::id() const {
  // @@protoc_insertion_point(field_get:adam.map.Connection.id)
  return id_.GetNoArena();
}
inline void Connection::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Connection.id)
}
#if LANG_CXX11
inline void Connection::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Connection.id)
}
#endif
inline void Connection::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Connection.id)
}
inline void Connection::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Connection.id)
}
inline ::std::string* Connection::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Connection.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connection::release_id() {
  // @@protoc_insertion_point(field_release:adam.map.Connection.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connection::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Connection.id)
}

// string incoming_road = 2;
inline void Connection::clear_incoming_road() {
  incoming_road_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connection::incoming_road() const {
  // @@protoc_insertion_point(field_get:adam.map.Connection.incoming_road)
  return incoming_road_.GetNoArena();
}
inline void Connection::set_incoming_road(const ::std::string& value) {
  
  incoming_road_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Connection.incoming_road)
}
#if LANG_CXX11
inline void Connection::set_incoming_road(::std::string&& value) {
  
  incoming_road_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Connection.incoming_road)
}
#endif
inline void Connection::set_incoming_road(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  incoming_road_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Connection.incoming_road)
}
inline void Connection::set_incoming_road(const char* value, size_t size) {
  
  incoming_road_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Connection.incoming_road)
}
inline ::std::string* Connection::mutable_incoming_road() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Connection.incoming_road)
  return incoming_road_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connection::release_incoming_road() {
  // @@protoc_insertion_point(field_release:adam.map.Connection.incoming_road)
  
  return incoming_road_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connection::set_allocated_incoming_road(::std::string* incoming_road) {
  if (incoming_road != NULL) {
    
  } else {
    
  }
  incoming_road_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), incoming_road);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Connection.incoming_road)
}

// string connecting_road = 3;
inline void Connection::clear_connecting_road() {
  connecting_road_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connection::connecting_road() const {
  // @@protoc_insertion_point(field_get:adam.map.Connection.connecting_road)
  return connecting_road_.GetNoArena();
}
inline void Connection::set_connecting_road(const ::std::string& value) {
  
  connecting_road_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Connection.connecting_road)
}
#if LANG_CXX11
inline void Connection::set_connecting_road(::std::string&& value) {
  
  connecting_road_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Connection.connecting_road)
}
#endif
inline void Connection::set_connecting_road(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  connecting_road_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Connection.connecting_road)
}
inline void Connection::set_connecting_road(const char* value, size_t size) {
  
  connecting_road_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Connection.connecting_road)
}
inline ::std::string* Connection::mutable_connecting_road() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Connection.connecting_road)
  return connecting_road_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connection::release_connecting_road() {
  // @@protoc_insertion_point(field_release:adam.map.Connection.connecting_road)
  
  return connecting_road_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connection::set_allocated_connecting_road(::std::string* connecting_road) {
  if (connecting_road != NULL) {
    
  } else {
    
  }
  connecting_road_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connecting_road);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Connection.connecting_road)
}

// string contact_point = 4;
inline void Connection::clear_contact_point() {
  contact_point_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connection::contact_point() const {
  // @@protoc_insertion_point(field_get:adam.map.Connection.contact_point)
  return contact_point_.GetNoArena();
}
inline void Connection::set_contact_point(const ::std::string& value) {
  
  contact_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Connection.contact_point)
}
#if LANG_CXX11
inline void Connection::set_contact_point(::std::string&& value) {
  
  contact_point_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Connection.contact_point)
}
#endif
inline void Connection::set_contact_point(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contact_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Connection.contact_point)
}
inline void Connection::set_contact_point(const char* value, size_t size) {
  
  contact_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Connection.contact_point)
}
inline ::std::string* Connection::mutable_contact_point() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Connection.contact_point)
  return contact_point_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connection::release_contact_point() {
  // @@protoc_insertion_point(field_release:adam.map.Connection.contact_point)
  
  return contact_point_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connection::set_allocated_contact_point(::std::string* contact_point) {
  if (contact_point != NULL) {
    
  } else {
    
  }
  contact_point_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contact_point);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Connection.contact_point)
}

// repeated .adam.map.ConnectionLaneLink lane_link = 5;
inline int Connection::lane_link_size() const {
  return lane_link_.size();
}
inline void Connection::clear_lane_link() {
  lane_link_.Clear();
}
inline ::adam::map::ConnectionLaneLink* Connection::mutable_lane_link(int index) {
  // @@protoc_insertion_point(field_mutable:adam.map.Connection.lane_link)
  return lane_link_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::adam::map::ConnectionLaneLink >*
Connection::mutable_lane_link() {
  // @@protoc_insertion_point(field_mutable_list:adam.map.Connection.lane_link)
  return &lane_link_;
}
inline const ::adam::map::ConnectionLaneLink& Connection::lane_link(int index) const {
  // @@protoc_insertion_point(field_get:adam.map.Connection.lane_link)
  return lane_link_.Get(index);
}
inline ::adam::map::ConnectionLaneLink* Connection::add_lane_link() {
  // @@protoc_insertion_point(field_add:adam.map.Connection.lane_link)
  return lane_link_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::adam::map::ConnectionLaneLink >&
Connection::lane_link() const {
  // @@protoc_insertion_point(field_list:adam.map.Connection.lane_link)
  return lane_link_;
}

// -------------------------------------------------------------------

// ConnectionLaneLink

// int32 from = 1;
inline void ConnectionLaneLink::clear_from() {
  from_ = 0;
}
inline ::google::protobuf::int32 ConnectionLaneLink::from() const {
  // @@protoc_insertion_point(field_get:adam.map.ConnectionLaneLink.from)
  return from_;
}
inline void ConnectionLaneLink::set_from(::google::protobuf::int32 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:adam.map.ConnectionLaneLink.from)
}

// int32 to = 2;
inline void ConnectionLaneLink::clear_to() {
  to_ = 0;
}
inline ::google::protobuf::int32 ConnectionLaneLink::to() const {
  // @@protoc_insertion_point(field_get:adam.map.ConnectionLaneLink.to)
  return to_;
}
inline void ConnectionLaneLink::set_to(::google::protobuf::int32 value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:adam.map.ConnectionLaneLink.to)
}

// -------------------------------------------------------------------

// RoadLink

// .adam.map.RoadLinker predecessor = 1;
inline bool RoadLink::has_predecessor() const {
  return this != internal_default_instance() && predecessor_ != NULL;
}
inline void RoadLink::clear_predecessor() {
  if (GetArenaNoVirtual() == NULL && predecessor_ != NULL) {
    delete predecessor_;
  }
  predecessor_ = NULL;
}
inline const ::adam::map::RoadLinker& RoadLink::_internal_predecessor() const {
  return *predecessor_;
}
inline const ::adam::map::RoadLinker& RoadLink::predecessor() const {
  const ::adam::map::RoadLinker* p = predecessor_;
  // @@protoc_insertion_point(field_get:adam.map.RoadLink.predecessor)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::RoadLinker*>(
      &::adam::map::_RoadLinker_default_instance_);
}
inline ::adam::map::RoadLinker* RoadLink::release_predecessor() {
  // @@protoc_insertion_point(field_release:adam.map.RoadLink.predecessor)
  
  ::adam::map::RoadLinker* temp = predecessor_;
  predecessor_ = NULL;
  return temp;
}
inline ::adam::map::RoadLinker* RoadLink::mutable_predecessor() {
  
  if (predecessor_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::RoadLinker>(GetArenaNoVirtual());
    predecessor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.RoadLink.predecessor)
  return predecessor_;
}
inline void RoadLink::set_allocated_predecessor(::adam::map::RoadLinker* predecessor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete predecessor_;
  }
  if (predecessor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      predecessor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, predecessor, submessage_arena);
    }
    
  } else {
    
  }
  predecessor_ = predecessor;
  // @@protoc_insertion_point(field_set_allocated:adam.map.RoadLink.predecessor)
}

// .adam.map.RoadLinker successor = 2;
inline bool RoadLink::has_successor() const {
  return this != internal_default_instance() && successor_ != NULL;
}
inline void RoadLink::clear_successor() {
  if (GetArenaNoVirtual() == NULL && successor_ != NULL) {
    delete successor_;
  }
  successor_ = NULL;
}
inline const ::adam::map::RoadLinker& RoadLink::_internal_successor() const {
  return *successor_;
}
inline const ::adam::map::RoadLinker& RoadLink::successor() const {
  const ::adam::map::RoadLinker* p = successor_;
  // @@protoc_insertion_point(field_get:adam.map.RoadLink.successor)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::RoadLinker*>(
      &::adam::map::_RoadLinker_default_instance_);
}
inline ::adam::map::RoadLinker* RoadLink::release_successor() {
  // @@protoc_insertion_point(field_release:adam.map.RoadLink.successor)
  
  ::adam::map::RoadLinker* temp = successor_;
  successor_ = NULL;
  return temp;
}
inline ::adam::map::RoadLinker* RoadLink::mutable_successor() {
  
  if (successor_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::RoadLinker>(GetArenaNoVirtual());
    successor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.RoadLink.successor)
  return successor_;
}
inline void RoadLink::set_allocated_successor(::adam::map::RoadLinker* successor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete successor_;
  }
  if (successor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      successor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, successor, submessage_arena);
    }
    
  } else {
    
  }
  successor_ = successor;
  // @@protoc_insertion_point(field_set_allocated:adam.map.RoadLink.successor)
}

// -------------------------------------------------------------------

// RoadLinker

// string element_type = 1;
inline void RoadLinker::clear_element_type() {
  element_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadLinker::element_type() const {
  // @@protoc_insertion_point(field_get:adam.map.RoadLinker.element_type)
  return element_type_.GetNoArena();
}
inline void RoadLinker::set_element_type(const ::std::string& value) {
  
  element_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.RoadLinker.element_type)
}
#if LANG_CXX11
inline void RoadLinker::set_element_type(::std::string&& value) {
  
  element_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.RoadLinker.element_type)
}
#endif
inline void RoadLinker::set_element_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  element_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.RoadLinker.element_type)
}
inline void RoadLinker::set_element_type(const char* value, size_t size) {
  
  element_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.RoadLinker.element_type)
}
inline ::std::string* RoadLinker::mutable_element_type() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.RoadLinker.element_type)
  return element_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadLinker::release_element_type() {
  // @@protoc_insertion_point(field_release:adam.map.RoadLinker.element_type)
  
  return element_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadLinker::set_allocated_element_type(::std::string* element_type) {
  if (element_type != NULL) {
    
  } else {
    
  }
  element_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), element_type);
  // @@protoc_insertion_point(field_set_allocated:adam.map.RoadLinker.element_type)
}

// string element_id = 2;
inline void RoadLinker::clear_element_id() {
  element_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadLinker::element_id() const {
  // @@protoc_insertion_point(field_get:adam.map.RoadLinker.element_id)
  return element_id_.GetNoArena();
}
inline void RoadLinker::set_element_id(const ::std::string& value) {
  
  element_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.RoadLinker.element_id)
}
#if LANG_CXX11
inline void RoadLinker::set_element_id(::std::string&& value) {
  
  element_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.RoadLinker.element_id)
}
#endif
inline void RoadLinker::set_element_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  element_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.RoadLinker.element_id)
}
inline void RoadLinker::set_element_id(const char* value, size_t size) {
  
  element_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.RoadLinker.element_id)
}
inline ::std::string* RoadLinker::mutable_element_id() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.RoadLinker.element_id)
  return element_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadLinker::release_element_id() {
  // @@protoc_insertion_point(field_release:adam.map.RoadLinker.element_id)
  
  return element_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadLinker::set_allocated_element_id(::std::string* element_id) {
  if (element_id != NULL) {
    
  } else {
    
  }
  element_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), element_id);
  // @@protoc_insertion_point(field_set_allocated:adam.map.RoadLinker.element_id)
}

// string contact_point = 3;
inline void RoadLinker::clear_contact_point() {
  contact_point_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadLinker::contact_point() const {
  // @@protoc_insertion_point(field_get:adam.map.RoadLinker.contact_point)
  return contact_point_.GetNoArena();
}
inline void RoadLinker::set_contact_point(const ::std::string& value) {
  
  contact_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.RoadLinker.contact_point)
}
#if LANG_CXX11
inline void RoadLinker::set_contact_point(::std::string&& value) {
  
  contact_point_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.RoadLinker.contact_point)
}
#endif
inline void RoadLinker::set_contact_point(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contact_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.RoadLinker.contact_point)
}
inline void RoadLinker::set_contact_point(const char* value, size_t size) {
  
  contact_point_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.RoadLinker.contact_point)
}
inline ::std::string* RoadLinker::mutable_contact_point() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.RoadLinker.contact_point)
  return contact_point_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadLinker::release_contact_point() {
  // @@protoc_insertion_point(field_release:adam.map.RoadLinker.contact_point)
  
  return contact_point_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadLinker::set_allocated_contact_point(::std::string* contact_point) {
  if (contact_point != NULL) {
    
  } else {
    
  }
  contact_point_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contact_point);
  // @@protoc_insertion_point(field_set_allocated:adam.map.RoadLinker.contact_point)
}

// -------------------------------------------------------------------

// Road

// string name = 1;
inline void Road::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Road::name() const {
  // @@protoc_insertion_point(field_get:adam.map.Road.name)
  return name_.GetNoArena();
}
inline void Road::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Road.name)
}
#if LANG_CXX11
inline void Road::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Road.name)
}
#endif
inline void Road::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Road.name)
}
inline void Road::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Road.name)
}
inline ::std::string* Road::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Road.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Road::release_name() {
  // @@protoc_insertion_point(field_release:adam.map.Road.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Road::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Road.name)
}

// string id = 3;
inline void Road::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Road::id() const {
  // @@protoc_insertion_point(field_get:adam.map.Road.id)
  return id_.GetNoArena();
}
inline void Road::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.Road.id)
}
#if LANG_CXX11
inline void Road::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.Road.id)
}
#endif
inline void Road::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.Road.id)
}
inline void Road::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.Road.id)
}
inline ::std::string* Road::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.Road.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Road::release_id() {
  // @@protoc_insertion_point(field_release:adam.map.Road.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Road::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:adam.map.Road.id)
}

// .adam.map.RoadLink link = 5;
inline bool Road::has_link() const {
  return this != internal_default_instance() && link_ != NULL;
}
inline void Road::clear_link() {
  if (GetArenaNoVirtual() == NULL && link_ != NULL) {
    delete link_;
  }
  link_ = NULL;
}
inline const ::adam::map::RoadLink& Road::_internal_link() const {
  return *link_;
}
inline const ::adam::map::RoadLink& Road::link() const {
  const ::adam::map::RoadLink* p = link_;
  // @@protoc_insertion_point(field_get:adam.map.Road.link)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::RoadLink*>(
      &::adam::map::_RoadLink_default_instance_);
}
inline ::adam::map::RoadLink* Road::release_link() {
  // @@protoc_insertion_point(field_release:adam.map.Road.link)
  
  ::adam::map::RoadLink* temp = link_;
  link_ = NULL;
  return temp;
}
inline ::adam::map::RoadLink* Road::mutable_link() {
  
  if (link_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::RoadLink>(GetArenaNoVirtual());
    link_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.Road.link)
  return link_;
}
inline void Road::set_allocated_link(::adam::map::RoadLink* link) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete link_;
  }
  if (link) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      link = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, link, submessage_arena);
    }
    
  } else {
    
  }
  link_ = link;
  // @@protoc_insertion_point(field_set_allocated:adam.map.Road.link)
}

// .adam.map.PlainView plain_view = 6;
inline bool Road::has_plain_view() const {
  return this != internal_default_instance() && plain_view_ != NULL;
}
inline void Road::clear_plain_view() {
  if (GetArenaNoVirtual() == NULL && plain_view_ != NULL) {
    delete plain_view_;
  }
  plain_view_ = NULL;
}
inline const ::adam::map::PlainView& Road::_internal_plain_view() const {
  return *plain_view_;
}
inline const ::adam::map::PlainView& Road::plain_view() const {
  const ::adam::map::PlainView* p = plain_view_;
  // @@protoc_insertion_point(field_get:adam.map.Road.plain_view)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::PlainView*>(
      &::adam::map::_PlainView_default_instance_);
}
inline ::adam::map::PlainView* Road::release_plain_view() {
  // @@protoc_insertion_point(field_release:adam.map.Road.plain_view)
  
  ::adam::map::PlainView* temp = plain_view_;
  plain_view_ = NULL;
  return temp;
}
inline ::adam::map::PlainView* Road::mutable_plain_view() {
  
  if (plain_view_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::PlainView>(GetArenaNoVirtual());
    plain_view_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.Road.plain_view)
  return plain_view_;
}
inline void Road::set_allocated_plain_view(::adam::map::PlainView* plain_view) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete plain_view_;
  }
  if (plain_view) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      plain_view = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, plain_view, submessage_arena);
    }
    
  } else {
    
  }
  plain_view_ = plain_view;
  // @@protoc_insertion_point(field_set_allocated:adam.map.Road.plain_view)
}

// repeated .adam.map.Lanes lanes = 9;
inline int Road::lanes_size() const {
  return lanes_.size();
}
inline void Road::clear_lanes() {
  lanes_.Clear();
}
inline ::adam::map::Lanes* Road::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:adam.map.Road.lanes)
  return lanes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::adam::map::Lanes >*
Road::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:adam.map.Road.lanes)
  return &lanes_;
}
inline const ::adam::map::Lanes& Road::lanes(int index) const {
  // @@protoc_insertion_point(field_get:adam.map.Road.lanes)
  return lanes_.Get(index);
}
inline ::adam::map::Lanes* Road::add_lanes() {
  // @@protoc_insertion_point(field_add:adam.map.Road.lanes)
  return lanes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::adam::map::Lanes >&
Road::lanes() const {
  // @@protoc_insertion_point(field_list:adam.map.Road.lanes)
  return lanes_;
}

// -------------------------------------------------------------------

// A

// -------------------------------------------------------------------

// B

// string name = 1;
inline void B::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& B::name() const {
  // @@protoc_insertion_point(field_get:adam.map.B.name)
  return name_.GetNoArena();
}
inline void B::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:adam.map.B.name)
}
#if LANG_CXX11
inline void B::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:adam.map.B.name)
}
#endif
inline void B::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:adam.map.B.name)
}
inline void B::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:adam.map.B.name)
}
inline ::std::string* B::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:adam.map.B.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* B::release_name() {
  // @@protoc_insertion_point(field_release:adam.map.B.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void B::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:adam.map.B.name)
}

// -------------------------------------------------------------------

// Map

// .adam.map.Header header = 1;
inline bool Map::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Map::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::adam::map::Header& Map::_internal_header() const {
  return *header_;
}
inline const ::adam::map::Header& Map::header() const {
  const ::adam::map::Header* p = header_;
  // @@protoc_insertion_point(field_get:adam.map.Map.header)
  return p != NULL ? *p : *reinterpret_cast<const ::adam::map::Header*>(
      &::adam::map::_Header_default_instance_);
}
inline ::adam::map::Header* Map::release_header() {
  // @@protoc_insertion_point(field_release:adam.map.Map.header)
  
  ::adam::map::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::adam::map::Header* Map::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::adam::map::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:adam.map.Map.header)
  return header_;
}
inline void Map::set_allocated_header(::adam::map::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:adam.map.Map.header)
}

// repeated .adam.map.Road road = 2;
inline int Map::road_size() const {
  return road_.size();
}
inline void Map::clear_road() {
  road_.Clear();
}
inline ::adam::map::Road* Map::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:adam.map.Map.road)
  return road_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::adam::map::Road >*
Map::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:adam.map.Map.road)
  return &road_;
}
inline const ::adam::map::Road& Map::road(int index) const {
  // @@protoc_insertion_point(field_get:adam.map.Map.road)
  return road_.Get(index);
}
inline ::adam::map::Road* Map::add_road() {
  // @@protoc_insertion_point(field_add:adam.map.Map.road)
  return road_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::adam::map::Road >&
Map::road() const {
  // @@protoc_insertion_point(field_list:adam.map.Map.road)
  return road_;
}

// repeated .adam.map.Junction junction = 3;
inline int Map::junction_size() const {
  return junction_.size();
}
inline void Map::clear_junction() {
  junction_.Clear();
}
inline ::adam::map::Junction* Map::mutable_junction(int index) {
  // @@protoc_insertion_point(field_mutable:adam.map.Map.junction)
  return junction_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::adam::map::Junction >*
Map::mutable_junction() {
  // @@protoc_insertion_point(field_mutable_list:adam.map.Map.junction)
  return &junction_;
}
inline const ::adam::map::Junction& Map::junction(int index) const {
  // @@protoc_insertion_point(field_get:adam.map.Map.junction)
  return junction_.Get(index);
}
inline ::adam::map::Junction* Map::add_junction() {
  // @@protoc_insertion_point(field_add:adam.map.Map.junction)
  return junction_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::adam::map::Junction >&
Map::junction() const {
  // @@protoc_insertion_point(field_list:adam.map.Map.junction)
  return junction_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace map
}  // namespace adam

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_proto_2fmap_2eproto
