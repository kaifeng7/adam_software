#include "opencv2/calib3d.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/core/utility.hpp"
#include "opencv2/ximgproc/disparity_filter.hpp"
#include <iostream>
#include <string>

#include <sl_zed/Camera.hpp>

using namespace cv;
using namespace cv::ximgproc;
using namespace std;
//function declear
cv::Mat slMat2cvMat(sl::Mat& input);


Rect computeROI(Size2i src_sz, Ptr<StereoMatcher> matcher_instance);

const String keys =
"{help h usage ? |                  | print this message                                                }"
"{@left          |../data/aloeL.jpg | left view of the stereopair                                       }"
"{@right         |../data/aloeR.jpg | right view of the stereopair                                      }"
"{GT             |../data/aloeGT.png| optional ground-truth disparity (MPI-Sintel or Middlebury format) }"
"{dst_path       |None              | optional path to save the resulting filtered disparity map        }"
"{dst_raw_path   |None              | optional path to save raw disparity map before filtering          }"
"{algorithm      |bm                | stereo matching method (bm or sgbm)                               }"
"{filter         |wls_conf          | used post-filtering (wls_conf or wls_no_conf)                     }"
"{no-display     |                  | don't display results                                             }"
"{no-downscale   |                  | force stereo matching on full-sized views to improve quality      }"
"{dst_conf_path  |None              | optional path to save the confidence map used in filtering        }"
"{vis_mult       |1.0               | coefficient used to scale disparity map visualizations            }"
"{max_disparity  |160               | parameter of stereo matching                                      }"
"{window_size    |-1                | parameter of stereo matching                                      }"
"{wls_lambda     |8000.0            | parameter of post-filtering                                       }"
"{wls_sigma      |1.5               | parameter of post-filtering                                       }"
;

int main(int argc, char** argv)
{







	//zed
	sl::Camera zed;
	// Set configuration parameters
	sl::InitParameters init_params;
	init_params.camera_resolution = sl::RESOLUTION_HD1080;
	init_params.depth_mode = sl::DEPTH_MODE_PERFORMANCE;
	init_params.coordinate_units = sl::UNIT_METER;

	//dispatity fliter
	cv::Ptr<DisparityWLSFilter> wls_filter;

	// Open the camera
	sl::ERROR_CODE err = zed.open(init_params);
	if (err != sl::SUCCESS) {
		printf("%s\n", toString(err).c_str());
		zed.close();
		return 1; // Quit if an error occurred
	}

	
	// Set runtime parameters after opening the camera
	sl::RuntimeParameters runtime_parameters;
	runtime_parameters.sensing_mode = sl::SENSING_MODE_STANDARD;

	// Prepare new image size to retrieve half-resolution images
	sl::Resolution image_size = zed.getResolution();
	int new_width = image_size.width / 2;
	int new_height = image_size.height / 2;

	// To share data between sl::Mat and cv::Mat, use slMat2cvMat()
	// Only the headers and pointer to the sl::Mat are copied, not the data itself
	sl::Mat image_zed_left(new_width, new_height,sl::MAT_TYPE_8U_C3);
	sl::Mat image_zed_right(new_width, new_height, sl::MAT_TYPE_8U_C3);
	Mat left = slMat2cvMat(image_zed_left);
	Mat right = slMat2cvMat(image_zed_right);

	//opencv
	CommandLineParser parser(argc, argv, keys);
	parser.about("Disparity Filtering Demo");
	if (parser.has("help"))
	{
		parser.printMessage();
		return 0;
	}

	//String left_im = parser.get<String>(0);
	//String right_im = parser.get<String>(1);
	//String GT_path = parser.get<String>("GT");

	String dst_path = parser.get<String>("dst_path");
	String dst_raw_path = parser.get<String>("dst_raw_path");
	String dst_conf_path = parser.get<String>("dst_conf_path");
	String algo = parser.get<String>("algorithm");
	String filter = parser.get<String>("filter");

	bool no_display = parser.has("no-display");
	bool no_downscale = parser.has("no-downscale");
	int max_disp = parser.get<int>("max_disparity");
	double lambda = parser.get<double>("wls_lambda");
	double sigma = parser.get<double>("wls_sigma");
	double vis_mult = parser.get<double>("vis_mult");

	int wsize = 21;

	if (!parser.check())
	{
		parser.printErrors();
		return -1;
	}

	//! [load_views]
	/*Mat left = imread(left_im, IMREAD_COLOR);
	if (left.empty())
	{
		cout << "Cannot read image file: " << left_im;
		return -1;
	}

	Mat right = imread(right_im, IMREAD_COLOR);
	if (right.empty())
	{
		cout << "Cannot read image file: " << right_im;
		return -1;
	}
	//! [load_views]

	bool noGT;
	Mat GT_disp;
	if (GT_path == "../data/aloeGT.png" && left_im != "../data/aloeL.jpg")
		noGT = true;
	else
	{
		noGT = false;
		if (readGT(GT_path, GT_disp) != 0)
		{
			cout << "Cannot read ground truth image file: " << GT_path << endl;
			return -1;
		}
	}
	*/
	while (1)
	{
		if (zed.grab(runtime_parameters) == sl::SUCCESS) {

			// Retrieve the left image, depth image in half-resolution
			zed.retrieveImage(image_zed_left, sl::VIEW_LEFT, sl::MEM_CPU, new_width, new_height);
			zed.retrieveImage(image_zed_left, sl::VIEW_RIGHT, sl::MEM_CPU, new_width, new_height);
			/*
			Mat left_for_matcher = left;
			Mat right_for_matcher = right;
			Mat left_disp, right_disp;
			Mat filtered_disp;
			Mat conf_map = Mat(left.rows, left.cols, CV_8U);
			conf_map = Scalar(255);
			Rect ROI;
			Ptr<DisparityWLSFilter> wls_filter;
			double matching_time, filtering_time;
			if (max_disp <= 0 || max_disp % 16 != 0)
			{
				cout << "Incorrect max_disparity value: it should be positive and divisible by 16";
				return -1;
			}
			if (wsize <= 0 || wsize % 2 != 1)
			{
				cout << "Incorrect window_size value: it should be positive and odd";
				return -1;
			}
			if (filter == "wls_conf") // filtering with confidence (significantly better quality than wls_no_conf)
			{
				if (!no_downscale)
				{
					// downscale the views to speed-up the matching stage, as we will need to compute both left
					// and right disparity maps for confidence map computation
					//! [downscale]
					max_disp /= 2;
					if (max_disp % 16 != 0)
						max_disp += 16 - (max_disp % 16);
					resize(left, left_for_matcher, Size(), 0.5, 0.5);
					resize(right, right_for_matcher, Size(), 0.5, 0.5);
					//! [downscale]
				}
				//else
				//{
				//}

				if (algo == "bm")
				{
					//! [matching]
					Ptr<StereoBM> left_matcher = StereoBM::create(max_disp, wsize);
					wls_filter = createDisparityWLSFilter(left_matcher);
					Ptr<StereoMatcher> right_matcher = createRightMatcher(left_matcher);

					//cvtColor(left, left_for_matcher, COLOR_BGR2GRAY);
					//cvtColor(right, right_for_matcher, COLOR_BGR2GRAY);

					matching_time = (double)getTickCount();
					left_matcher->compute(left_for_matcher, right_for_matcher, left_disp);
					right_matcher->compute(right_for_matcher, left_for_matcher, right_disp);
					matching_time = ((double)getTickCount() - matching_time) / getTickFrequency();
					//! [matching]
				}
				//! [filtering]
				wls_filter->setLambda(lambda);
				wls_filter->setSigmaColor(sigma);
				filtering_time = (double)getTickCount();
				wls_filter->filter(left_disp, left, filtered_disp, right_disp);
				filtering_time = ((double)getTickCount() - filtering_time) / getTickFrequency();
				//! [filtering]
				//conf_map = wls_filter->getConfidenceMap();

				// Get the ROI that was used in the last filter call:
				ROI = wls_filter->getROI();
				if (!no_downscale)
				{
					// upscale raw disparity and ROI back for a proper comparison:
					resize(left_disp, left_disp, Size(), 2.0, 2.0);
					left_disp = left_disp*2.0;
					ROI = Rect(ROI.x * 2, ROI.y * 2, ROI.width * 2, ROI.height * 2);
				}
			}
			else
			{
				cout << "Unsupported filter";
				return -1;
			}

			//collect and print all the stats:
			cout.precision(2);
			cout << "Matching time:  " << matching_time << "s" << endl;
			cout << "Filtering time: " << filtering_time << "s" << endl;
			cout << endl;

			double MSE_before, percent_bad_before, MSE_after, percent_bad_after;
			*/
				//namedWindow("left", WINDOW_AUTOSIZE);
				imshow("left", left);
				//namedWindow("right", WINDOW_AUTOSIZE);
				imshow("right", right);
				//! [visualization]
				Mat raw_disp_vis;
//				getDisparityVis(left_disp, raw_disp_vis, vis_mult);
				//namedWindow("raw disparity", WINDOW_AUTOSIZE);
			//	imshow("raw disparity", raw_disp_vis);
				//Mat filtered_disp_vis;
				//getDisparityVis(filtered_disp, filtered_disp_vis, vis_mult);
				//namedWindow("filtered disparity", WINDOW_AUTOSIZE);
			//	imshow("filtered disparity", filtered_disp_vis);

				//! [visualization]}
		}
	}
}

Rect computeROI(Size2i src_sz, Ptr<StereoMatcher> matcher_instance)
{
	int min_disparity = matcher_instance->getMinDisparity();
	int num_disparities = matcher_instance->getNumDisparities();
	int block_size = matcher_instance->getBlockSize();

	int bs2 = block_size / 2;
	int minD = min_disparity, maxD = min_disparity + num_disparities - 1;

	int xmin = maxD + bs2;
	int xmax = src_sz.width + minD - bs2;
	int ymin = bs2;
	int ymax = src_sz.height - bs2;

	Rect r(xmin, ymin, xmax - xmin, ymax - ymin);
	return r;
}

    Mat slMat2cvMat(sl::Mat& input) {
	// Mapping between MAT_TYPE and CV_TYPE
	int cv_type = -1;
	switch (input.getDataType()) {
	case sl::MAT_TYPE_32F_C1: cv_type = CV_32FC1; break;
	case sl::MAT_TYPE_32F_C2: cv_type = CV_32FC2; break;
	case sl::MAT_TYPE_32F_C3: cv_type = CV_32FC3; break;
	case sl::MAT_TYPE_32F_C4: cv_type = CV_32FC4; break;
	case sl::MAT_TYPE_8U_C1: cv_type = CV_8UC1; break;
	case sl::MAT_TYPE_8U_C2: cv_type = CV_8UC2; break;
	case sl::MAT_TYPE_8U_C3: cv_type = CV_8UC3; break;
	case sl::MAT_TYPE_8U_C4: cv_type = CV_8UC4; break;
	default: break;
	}

	// Since cv::Mat data requires a uchar* pointer, we get the uchar1 pointer from sl::Mat (getPtr<T>())
	// cv::Mat and sl::Mat will share a single memory structure
	return Mat(input.getHeight(), input.getWidth(), cv_type, input.getPtr<sl::uchar1>(sl::MEM_CPU));
}
